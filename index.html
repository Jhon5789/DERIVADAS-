function resolverMetodoLargo() {
  const funcion = document.getElementById("funcion").value.trim();
  const valorxRaw = document.getElementById("valorx").value.trim();
  const output = document.getElementById("output");
  const steps = document.getElementById("mathSteps");
  output.innerHTML = '';
  steps.innerHTML = '';

  if (!validarFuncion(funcion)) {
    output.textContent = "⚠️ Por favor, ingresa una función válida.";
    return;
  }
  if (valorxRaw === '') {
    output.textContent = "⚠️ Ingresa un valor numérico para x.";
    return;
  }
  const valorx = parseFloat(valorxRaw);
  if (isNaN(valorx)) {
    output.textContent = "⚠️ El valor de x debe ser un número válido.";
    return;
  }

  // Detectar si funcion es monomio x^n simple (como x^2)
  const monomioRegex = /^\s*x\^(\d+)\s*$/;
  const matchMonomio = funcion.match(monomioRegex);

  if (matchMonomio) {
    // Es monomio x^n
    const n = parseInt(matchMonomio[1]);
    if (n === 0) {
      output.textContent = "La derivada de una constante es 0.";
      steps.innerHTML = "";
      return;
    }

    // PASOS para x^n (ejemplo para que se vea como pediste)

    // Paso 1 - Definición formal
    let paso1 = `f'(x) = \\lim_{h \\to 0} \\frac{(x+h)^{${n}} - x^{${n}}}{h}`;

    // Paso 2 - Desarrollo del binomio (expansión usando binomio de Newton)
    // Expandimos hasta n=3 para que no sea enorme, si n>3 mostramos fórmula general

    let binomioExp = '';
    if (n <= 3) {
      // Generar sumatorio del binomio (x+h)^n = sum(k=0,n) C(n,k) x^{n-k} h^k
      let terminos = [];
      for (let k = 0; k <= n; k++) {
        let coef = factorial(n) / (factorial(k) * factorial(n - k));
        coef = coef === 1 ? '' : coef.toString();
        let xPot = n - k === 0 ? '' : `x^{${n - k}}`;
        let hPot = k === 0 ? '' : (k === 1 ? 'h' : `h^{${k}}`);
        let term = coef + xPot + hPot;
        // Simplificar ^1 y ^0 en LaTeX
        term = term.replace(/\^1([^\\d])/g, '$1').replace(/\^0/g, '');
        terminos.push(term);
      }
      binomioExp = terminos.join(' + ');
    } else {
      binomioExp = `(x+h)^{${n}} = \\sum_{k=0}^{${n}} \\binom{${n}}{k} x^{${n}-k} h^{k}`;
    }

    let paso2 = `(x+h)^{${n}} = ${binomioExp}`;

    // Paso 3 - Sustituyendo en límite
    let paso3 = `\\lim_{h \\to 0} \\frac{${binomioExp} - x^{${n}}}{h}`;

    // Paso 4 - Cancelar términos y factorizar h
    // Numerador = sum k=1..n C(n,k) x^{n-k} h^k
    // Sacamos h: h * sum k=1..n C(n,k) x^{n-k} h^{k-1}
    // Expandimos para n<=3 para mostrar

    let numeradorSinXn = '';
    if (n <= 3) {
      let terminosNum = [];
      for (let k = 1; k <= n; k++) {
        let coef = factorial(n) / (factorial(k) * factorial(n - k));
        coef = coef === 1 ? '' : coef.toString();
        let xPot = n - k === 0 ? '' : `x^{${n - k}}`;
        let hPot = (k - 1) === 0 ? '' : (k - 1 === 1 ? 'h' : `h^{${k - 1}}`);
        let term = coef + xPot + hPot;
        term = term.replace(/\^1([^\\d])/g, '$1').replace(/\^0/g, '');
        terminosNum.push(term);
      }
      numeradorSinXn = terminosNum.join(' + ');
    } else {
      numeradorSinXn = `\\sum_{k=1}^{${n}} \\binom{${n}}{k} x^{${n}-k} h^{k-1}`;
    }

    let paso4 = `\\lim_{h \\to 0} \\frac{h \\left(${numeradorSinXn}\\right)}{h} = \\lim_{h \\to 0} \\left(${numeradorSinXn}\\right)`;

    // Paso 5 - Aplicar límite h->0 (todos los términos con h desaparecen menos k=1)
    let coefK1 = factorial(n) / (factorial(1) * factorial(n - 1));
    let paso5 = `= ${coefK1} x^{${n - 1}} = ${coefK1}x^{${n - 1}}`;

    // Resultado final
    let resultado = `f'(x) = ${coefK1}x^{${n - 1}}`;

    // Mostrar todo
    output.innerHTML = `\\[
      \\text{Función: } f(x) = x^{${n}}
    \\]`;

    steps.innerHTML = `\\[
      \\text{Paso 1 – Definición formal:} \\\\
      ${paso1} \\\\[10pt]
      \\text{Paso 2 – Desarrollo del binomio:} \\\\
      ${paso2} \\\\[10pt]
      \\text{Paso 3 – Sustituyendo:} \\\\
      ${paso3} \\\\[10pt]
      \\text{Paso 4 – Cancelar términos:} \\\\
      ${paso4} \\\\[10pt]
      \\text{Paso 5 – Aplicar límite:} \\\\
      ${paso5} \\\\[10pt]
      \\text{Resultado final:} \\\\
      ${resultado}
    \\]`;

    MathJax.typesetPromise();
    return;
  }

  // Si no es monomio x^n, usar versión general (definición, sustitución simbólica, cálculo numérico, derivada simbólica)
  // Copia aquí tu versión general anterior (como en el código que te di antes)

  // Código fallback (versión general):

  const h = 0.000001;
  try {
    const f_x = math.evaluate(funcion, { x: valorx });
    const funcionConXh = funcion.replace(/x/g, `(x + h)`);
    const f_xh = math.evaluate(funcionConXh, { x: valorx, h: h });
    const diferencia = (f_xh - f_x) / h;
    const f_xh_latex = math.parse(funcionConXh).toTex();
    const f_x_latex = math.parse(funcion).toTex();
    const derivadaSimbolica = math.derivative(funcion, 'x').toString();
    const derivadaSimbolicaTex = math.parse(derivadaSimbolica).toTex();
    const valorDerivadaEnX = math.evaluate(derivadaSimbolica, { x: valorx });

    let paso1 = `f'(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h}`;
    let paso2 = `= \\lim_{h \\to 0} \\frac{${f_xh_latex} - ${f_x_latex}}{h}`;
    let paso3 = `\\approx \\frac{f(${valorx} + h) - f(${valorx})}{h} = \\frac{${f_xh.toFixed(7)} - ${f_x.toFixed(7)}}{${h}} = ${diferencia.toFixed(7)}`;
    let paso4 = `\\text{Derivada simbólica: } f'(x) = ${derivadaSimbolicaTex}`;
    let paso5 = `\\text{Valor numérico en } x=${valorx}: f'(${valorx}) = ${valorDerivadaEnX.toFixed(7)}`;

    output.innerHTML = `\\[
      \\text{Función: } f(x) = ${f_x_latex}
    \\]`;

    steps.innerHTML = `\\[
      \\text{Paso 1 – Definición formal:} \\\\
      ${paso1} \\\\[10pt]
      \\text{Paso 2 – Sustitución:} \\\\
      ${paso2} \\\\[10pt]
      \\text{Paso 3 – Cálculo numérico aproximado:} \\\\
      ${paso3} \\\\[10pt]
      \\text{Paso 4 – Derivada simbólica:} \\\\
      ${paso4} \\\\[10pt]
      \\text{Paso 5 – Valor numérico en } x=${valorx}: \\\\
      ${paso5}
    \\]`;

    MathJax.typesetPromise();

  } catch (error) {
    output.textContent = "⚠️ Error al evaluar la función. Verifica la expresión.";
  }
}

function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}
